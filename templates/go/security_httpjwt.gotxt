package openapi

import (

	"net/http"
	// "os"
	"time"
	log "github.com/sirupsen/logrus"
	jwt "github.com/appleboy/gin-jwt/v2"
	"github.com/gin-gonic/gin"
  )

var AuthMiddleware *jwt.GinJWTMiddleware
var identityKey = "id"
func InitiateJWT() {
	
	var realm = "realm1"
	var secretkey = "secret1"
	SecuritySchemelist["jwt"] = true
	type login struct {
		Username string `form:"username" json:"username" binding:"required"`
		Password string `form:"password" json:"password" binding:"required"`
	  }
	// User demo
	type User struct {
		UserName  string
		FirstName string
		LastName  string
	}
		
  // the jwt middleware
  	var err error
  	AuthMiddleware, err = jwt.New(&jwt.GinJWTMiddleware{
		Realm:       realm,
		Key:         []byte(secretkey),
		Timeout:     time.Hour,
		MaxRefresh:  time.Hour,
		IdentityKey: identityKey,
		PayloadFunc: func(data interface{}) jwt.MapClaims {
			if v, ok := data.(*User); ok {
			return jwt.MapClaims{
				identityKey: v.UserName,
			}
			}
			return jwt.MapClaims{}
	},
	IdentityHandler: func(c *gin.Context) interface{} {
		claims := jwt.ExtractClaims(c)
		return &User{
		UserName: claims[identityKey].(string),
		}
	},
	Authenticator: func(c *gin.Context) (interface{}, error) {
		var loginVals login
		if err := c.ShouldBind(&loginVals); err != nil {
		return "", jwt.ErrMissingLoginValues
		}
		userID := loginVals.Username
		password := loginVals.Password

		if (userID == "admin" && password == "admin") || (userID == "test" && password == "test") {
		return &User{
			UserName:  userID,
			LastName:  "Bo-Yi",
			FirstName: "Wu",
		}, nil
		}

		return nil, jwt.ErrFailedAuthentication
	},
	Authorizator: func(data interface{}, c *gin.Context) bool {
		if v, ok := data.(*User); ok && v.UserName == "admin" {
		return true
		}

		return false
	},
	Unauthorized: func(c *gin.Context, code int, message string) {
		c.JSON(code, gin.H{
		"code":    code,
		"message": message,
		})
	},
	// TokenLookup is a string in the form of "<source>:<name>" that is used
	// to extract token from the request.
	// Optional. Default value "header:Authorization".
	// Possible values:
	// - "header:<name>"
	// - "query:<name>"
	// - "cookie:<name>"
	// - "param:<name>"
	TokenLookup: "header: Authorization, query: token, cookie: jwt",
	// TokenLookup: "query:token",
	// TokenLookup: "cookie:token",

	// TokenHeadName is a string in the header. Default value is "Bearer"
	TokenHeadName: "Bearer",

	// TimeFunc provides the current time. You can override it to use another time value. This is useful for testing or if your server uses a different time zone than your tokens.
	TimeFunc: time.Now,
	})

	if err != nil {
	log.Fatal("JWT Error:" + err.Error())
	}

	// When you use jwt.New(), the function is already automatically called for checking,
	// which means you don't need to call it again.
	errInit := AuthMiddleware.MiddlewareInit()

	if errInit != nil {
	log.Fatal("authMiddleware.MiddlewareInit() Error:" + errInit.Error())
	}
	
}

{{ with .Auth_handle}}{{range .}}
func {{.}}(c *gin.Context){
	claims := jwt.ExtractClaims(c)
	user, _ := c.Get(identityKey)
	userid := claims[identityKey]
	if userid ==  nil {
		log.Warn("Unauthorise request", user, userid)
		c.JSON(http.StatusUnauthorized, gin.H{"msg": "Unauthorise access, proper JWT token required."})
		c.Abort()
	}else{
		c.Next()
	}
}
{{end}}{{end}}